<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Demo Chatbot Th·ªùi trang</title>
  <style>
    :root {
      --bg: #0b1220;
      --text: #e5e7eb;
      --muted: rgba(229,231,235,0.75);
      --border: rgba(255,255,255,0.12);
      --accent: #2563eb;
      --accent-2: #22c55e;
      --shadow: 0 16px 60px rgba(0,0,0,0.45);
      --shadow-soft: 0 8px 24px rgba(0,0,0,0.25);
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      background:
        radial-gradient(900px 600px at 15% 10%, rgba(37,99,235,0.25), transparent 55%),
        radial-gradient(700px 520px at 85% 12%, rgba(34,197,94,0.14), transparent 60%),
        radial-gradient(900px 900px at 70% 90%, rgba(99,102,241,0.18), transparent 65%),
        var(--bg);
      color: var(--text);
    }

    header {
      padding: 18px 16px;
      border-bottom: 1px solid var(--border);
      backdrop-filter: blur(10px);
      background: rgba(11,18,32,0.55);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    header .brand {
      max-width: 980px;
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }
    header .brand h2 { margin: 0; font-size: 16px; letter-spacing: 0.2px; font-weight: 700; }
    header .brand .pill {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }
    .dot { width: 8px; height: 8px; border-radius: 999px; background: var(--accent-2); display: inline-block; box-shadow: 0 0 0 3px rgba(34,197,94,0.16); }

    main { max-width: 980px; margin: 0 auto; padding: 16px; }

    .chat-app {
      border-radius: 18px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.06);
      box-shadow: var(--shadow);
      overflow: hidden;
      min-height: calc(100vh - 92px);
      display: flex;
      flex-direction: column;
    }

    .chat-header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 12px;
    }
    .chat-title {
      display:flex;
      align-items:center;
      gap: 10px;
      min-width: 0;
    }
    .avatar {
      width: 34px;
      height: 34px;
      border-radius: 12px;
      display:flex;
      align-items:center;
      justify-content:center;
      border: 1px solid var(--border);
      background: rgba(255,255,255,0.08);
      flex: 0 0 auto;
      font-weight: 800;
      color: #fff;
    }
    .avatar.assistant { background: rgba(37,99,235,0.25); }
    .title-wrap { min-width: 0; }
    .title-wrap .name { font-weight: 750; font-size: 14px; margin: 0; }
    .title-wrap .sub { margin: 2px 0 0; font-size: 12px; color: var(--muted); }

    .header-actions { display:flex; gap: 8px; align-items:center; flex-wrap: wrap; justify-content: flex-end; }
    .muted { color: var(--muted); }

    button {
      background: var(--accent);
      color: #fff;
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 10px 14px;
      font-size: 14px;
      cursor: pointer;
    }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn-secondary { background: rgba(255,255,255,0.08); color: var(--text); }
    .btn-ghost { background: rgba(255,255,255,0.06); color: var(--text); }
    .btn-ghost:hover { background: rgba(255,255,255,0.08); }
    .btn-danger { background: rgba(239,68,68,0.95); }
    .btn-danger:hover { background: rgba(239,68,68,1); }

    .chat-body {
      flex: 1 1 auto;
      overflow: auto;
      padding: 16px 16px 12px;
      background:
        radial-gradient(600px 420px at 10% 30%, rgba(255,255,255,0.06), transparent 65%),
        radial-gradient(700px 520px at 80% 60%, rgba(255,255,255,0.05), transparent 70%),
        rgba(0,0,0,0.10);
    }

    .msg-row {
      display:flex;
      align-items: flex-end;
      gap: 10px;
      margin: 10px 0;
    }
    .msg-row.user { justify-content: flex-end; }
    .msg-row.assistant { justify-content: flex-start; }
    .msg-row.user .avatar { display: none; }

    .bubble {
      /*
        Gi·ªØ bong b√≥ng chat c·ªßa user/assistant c√πng ƒë·ªô r·ªông.
        Ch·ª´a m·ªôt ch√∫t kho·∫£ng ngang ƒë·ªÉ d√≤ng c·ªßa assistant (c√≥ avatar + kho·∫£ng c√°ch)
        kh√¥ng b·ªã tr√†n tr√™n m√†n h√¨nh h·∫πp.
      */
      width: min(720px, calc(100% - 54px));
      max-width: min(720px, calc(100% - 54px));
      padding: 10px 12px;
      border-radius: 16px;
      line-height: 1.5;
      overflow-wrap: break-word;
      /* G·ªôp kho·∫£ng tr·∫Øng trong layout; ch·ªâ gi·ªØ xu·ªëng d√≤ng b√™n trong .content */
      white-space: normal;
      box-shadow: var(--shadow-soft);
      height: auto;
    }
    .bubble.user {
      background: linear-gradient(180deg, rgba(37,99,235,0.92), rgba(37,99,235,0.78));
      border: 1px solid rgba(255,255,255,0.14);
      color: #fff;
      border-bottom-right-radius: 6px;
    }
    .bubble.assistant {
      background: rgba(255,255,255,0.92);
      border: 1px solid rgba(17,24,39,0.08);
      color: #111827;
      border-bottom-left-radius: 6px;
    }
    .bubble .meta {
      display:flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 6px;
      font-size: 12px;
      opacity: 0.8;
    }
    .bubble .meta .who { font-weight: 700; }
    .bubble .meta .time { font-variant-numeric: tabular-nums; }
    .bubble .content { font-size: 14px; white-space: pre-wrap; }

    .typing {
      display:inline-flex;
      gap: 4px;
      align-items:center;
      padding: 6px 0;
    }
    .typing i {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: rgba(17,24,39,0.35);
      display:inline-block;
      animation: blink 1.2s infinite ease-in-out;
    }
    .typing i:nth-child(2) { animation-delay: 0.15s; }
    .typing i:nth-child(3) { animation-delay: 0.3s; }
    @keyframes blink {
      0%, 80%, 100% { transform: translateY(0); opacity: 0.25; }
      40% { transform: translateY(-2px); opacity: 0.85; }
    }

    details { margin-top: 10px; }
    summary { cursor: pointer; }
    .source-item { border: 1px solid #e5e7eb; border-radius: 10px; padding: 10px; margin: 8px 0; background: #f9fafb; }

    .product-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(190px, 1fr)); gap: 12px; margin-top: 10px; }
    .product-card { border: 1px solid #e5e7eb; border-radius: 12px; background: #ffffff; overflow: hidden; box-shadow: 0 4px 12px rgba(0,0,0,0.06); }
    .product-img-wrap { background: #f3f4f6; height: 170px; display:flex; align-items:center; justify-content:center; }
    .product-img { max-width: 100%; max-height: 100%; object-fit: contain; display:block; }
    .product-body { padding: 10px 12px; }
    .product-title { font-weight: 700; font-size: 14px; line-height: 1.3; margin-bottom: 6px; }
    .product-meta { color: #6b7280; font-size: 12px; line-height: 1.4; }
    .badge { display:inline-block; font-size: 12px; padding: 2px 8px; border-radius: 999px; border: 1px solid #e5e7eb; background: #f9fafb; margin-right: 6px; margin-top: 6px; }
    .product-actions { margin-top: 8px; display:flex; gap:8px; flex-wrap:wrap; }
    .link-btn { display:inline-block; padding: 6px 10px; border-radius: 8px; border: 1px solid #d1d5db; background: #fff; color: #111827; text-decoration: none; font-size: 12px; }
    .link-btn:hover { border-color: #9ca3af; }

    .composer {
      border-top: 1px solid var(--border);
      background: rgba(255,255,255,0.05);
      padding: 12px 12px;
    }
    .composer-grid {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 10px;
      align-items: end;
    }
    textarea {
      width: 100%;
      min-height: 44px;
      max-height: 140px;
      resize: vertical;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,0.18);
      color: var(--text);
      outline: none;
      font-size: 14px;
    }
    textarea::placeholder { color: rgba(229,231,235,0.55); }
    textarea:focus { border-color: rgba(37,99,235,0.6); box-shadow: 0 0 0 3px rgba(37,99,235,0.18); }

    .composer-actions {
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }
    .composer-sub {
      margin-top: 8px;
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      flex-wrap: wrap;
    }
    .attach-row { display:flex; align-items:center; gap: 8px; flex-wrap: wrap; }
    .status { font-size: 12px; color: var(--muted); }

    .img-preview-wrap {
      margin-top: 10px;
      border: 1px solid var(--border);
      border-radius: 16px;
      background: rgba(0,0,0,0.16);
      padding: 10px;
      display:none;
    }
    .img-preview-head { display:flex; align-items:center; justify-content: space-between; gap: 10px; }
    .img-preview {
      margin-top: 8px;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    .img-preview img { max-width:100%; max-height:170px; object-fit:contain; border-radius: 12px; }

    .msg-image {
      margin-top: 8px;
      max-width: 100%;
      max-height: 240px;
      width: 100%;
      object-fit: contain;
      border-radius: 12px;
      border: 1px solid rgba(17,24,39,0.10);
      background: rgba(243,244,246,0.85);
      display: block;
    }

    @media (max-width: 520px) {
      .composer-grid { grid-template-columns: 1fr; }
      .composer-actions { justify-content: stretch; }
      .composer-actions button { width: 100%; }
    }
  </style>
</head>
<body>
  <header>
    <div class="brand">
      <h2>Demo Chatbot Th·ªùi trang</h2>
      <div class="pill"><span class="dot"></span> API: <span id="apiBaseLabel">http://127.0.0.1:8080</span></div>
    </div>
  </header>
  <main>
    <div class="chat-app">
      <div class="chat-header">
        <div class="chat-title">
          <div class="avatar assistant">F</div>
          <div class="title-wrap">
            <p class="name">Tr·ª£ l√Ω Th·ªùi trang</p>
            <p class="sub">H·ªèi v·ªÅ outfit, ng√¢n s√°ch, m√†u s·∫Øc, d·ªãp s·ª≠ d·ª•ng ‚Äî ho·∫∑c ƒë√≠nh k√®m ·∫£nh ƒë·ªÉ t√¨m ki·∫øm</p>
          </div>
        </div>
        <div class="header-actions">
          <button id="clearBtn" type="button" class="btn-secondary">Chat m·ªõi</button>
        </div>
      </div>

      <div id="chatWindow" class="chat-body" aria-label="Tin nh·∫Øn chat"></div>

      <div class="composer" aria-label="So·∫°n tin nh·∫Øn">
        <div class="composer-grid">
          <div>
            <textarea id="chatInput" rows="2" placeholder="Nh·∫≠p tin nh·∫Øn‚Ä¶ (Enter ƒë·ªÉ g·ª≠i, Shift+Enter ƒë·ªÉ xu·ªëng d√≤ng)"></textarea>

            <div class="img-preview-wrap" id="chatImagePreviewWrap">
              <div class="img-preview-head">
                <div class="muted" style="font-size:12px;">·∫¢nh ƒë√≠nh k√®m</div>
                <button id="removeImageBtn" type="button" class="btn-ghost" style="padding:6px 10px; font-size:12px;">G·ª°</button>
              </div>
              <div class="img-preview">
                <img id="chatImagePreview" alt="Xem tr∆∞·ªõc ·∫£nh ƒë√≠nh k√®m" />
              </div>
            </div>

            <div class="composer-sub">
              <div class="attach-row">
                <input id="chatImageFile" type="file" accept="image/*" style="display:none;" />
                <button id="attachBtn" type="button" class="btn-ghost">ƒê√≠nh k√®m ·∫£nh</button>
                <span id="attachHint" class="muted" style="font-size:12px;">(ho·∫∑c d√°n b·∫±ng Ctrl+V)</span>
              </div>
              <div id="chatStatus" class="status"></div>
            </div>
          </div>

          <div class="composer-actions">
            <button id="stopBtn" type="button" class="btn-danger" style="display:none;">D·ª´ng</button>
            <button id="sendBtn" type="button">G·ª≠i</button>
          </div>
        </div>
      </div>
    </div>
  </main>

  <script>
    const chatWindow = document.getElementById('chatWindow');
    const chatInput = document.getElementById('chatInput');
    const sendBtn = document.getElementById('sendBtn');
    const stopBtn = document.getElementById('stopBtn');
    const clearBtn = document.getElementById('clearBtn');
    const chatStatus = document.getElementById('chatStatus');

    const chatImageFile = document.getElementById('chatImageFile');
    const attachBtn = document.getElementById('attachBtn');
    const removeImageBtn = document.getElementById('removeImageBtn');
    const chatImagePreviewWrap = document.getElementById('chatImagePreviewWrap');
    const chatImagePreview = document.getElementById('chatImagePreview');

    // L∆∞u ·∫£nh ƒë∆∞·ª£c d√°n t·ª´ clipboard (khi ng∆∞·ªùi d√πng Ctrl+V ·∫£nh ƒë√£ copy).
    let pastedImageFile = null;
    let pastedObjectUrl = null;

    // ƒê√£ l∆∞·ª£c b·ªè ph·∫ßn settings: gi·ªØ demo ƒë∆°n gi·∫£n nh·∫•t.
    // N·∫øu b·∫°n ƒë·ªïi port backend, h√£y c·∫≠p nh·∫≠t h·∫±ng s·ªë n√†y.
    // D√πng 127.0.0.1 thay v√¨ localhost ƒë·ªÉ tr√°nh l·ªói ph√¢n gi·∫£i IPv6 (::1) tr√™n Windows
    // khi API ch·ªâ bind IPv4.
    const API_BASE = 'http://127.0.0.1:8081';

    const messages = []; // {role: 'user'|'assistant', content: string, ts: number, isTyping?: boolean}
    let typingMsgIndex = -1;

    // Cho ph√©p hu·ª∑ request ƒëang ch·∫°y ƒë·ªÉ ng∆∞·ªùi d√πng c√≥ th·ªÉ s·ª≠a c√¢u h·ªèi.
    let inFlightController = null;
    let lastDraftBeforeSend = '';
    let lastInFlightKind = ''; // 'chat' | 'image'

    function setInFlight(isInFlight, kind) {
      lastInFlightKind = isInFlight ? (kind || '') : '';
      sendBtn.disabled = Boolean(isInFlight);
      // V√¥ hi·ªáu ho√° n√∫t ƒë√≠nh k√®m trong l√∫c x·ª≠ l√Ω ƒë·ªÉ tr√°nh tr·∫°ng th√°i ‚Äúr·ªëi‚Äù.
      attachBtn.disabled = Boolean(isInFlight);
      removeImageBtn.disabled = Boolean(isInFlight);
      clearBtn.disabled = Boolean(isInFlight);
      // Ch·ªâ hi·ªán n√∫t d·ª´ng khi c√≥ request c√≥ th·ªÉ hu·ª∑.
      stopBtn.style.display = isInFlight ? 'inline-block' : 'none';
      stopBtn.disabled = !isInFlight;
    }

    function stopGenerating() {
      if (!inFlightController) return;
      try { inFlightController.abort(); } catch (_) {}
    }

    // Theo d√µi object URL t·∫°o cho bong b√≥ng chat ƒë·ªÉ c√≥ th·ªÉ revoke khi reset.
    const chatObjectUrls = [];

    function escapeHtml(s) {
      return String(s || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function apiUrl(path) {
      return `${API_BASE}${path}`;
    }

    function setChatStatus(text) {
      chatStatus.textContent = text;
    }

    function getAttachedImage() {
      if (chatImageFile.files && chatImageFile.files[0]) return chatImageFile.files[0];
      if (pastedImageFile) return pastedImageFile;
      return null;
    }

    function clearAttachedImage() {
      chatImageFile.value = '';
      pastedImageFile = null;
      if (pastedObjectUrl) {
        try { URL.revokeObjectURL(pastedObjectUrl); } catch (_) {}
        pastedObjectUrl = null;
      }
      chatImagePreview.src = '';
      chatImagePreviewWrap.style.display = 'none';
    }

    function showPreviewFromBlob(blob) {
      if (pastedObjectUrl) {
        try { URL.revokeObjectURL(pastedObjectUrl); } catch (_) {}
      }
      pastedObjectUrl = URL.createObjectURL(blob);
      chatImagePreview.src = pastedObjectUrl;
      chatImagePreviewWrap.style.display = 'block';
    }


    function formatTime(ts) {
      try {
        const d = new Date(ts);
        return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } catch (_) {
        return '';
      }
    }

    function renderTypingHtml() {
      return `<span class="typing" aria-label="Tr·ª£ l√Ω ƒëang nh·∫≠p"><i></i><i></i><i></i></span>`;
    }

    function renderChat() {
      chatWindow.innerHTML = messages.map((m, idx) => {
        const cls = m.role === 'user' ? 'user' : 'assistant';
        const who = m.role === 'user' ? 'B·∫°n' : 'Tr·ª£ l√Ω';
        const safe = escapeHtml(m.content || '');
        const imgSrc = (m && m.imageSrc) ? String(m.imageSrc) : '';
        const time = m.ts ? formatTime(m.ts) : '';
        const isTyping = Boolean(m.isTyping);
        const metaHtml = `<div class="meta"><span class="who">${who}</span><span class="time">${escapeHtml(time)}</span></div>`;
        const contentHtml = isTyping
          ? `<div class="content">${renderTypingHtml()}</div>`
          : `<div class="content">${safe}</div>`;

        const imageHtml = (!isTyping && imgSrc)
          ? `<img class="msg-image" src="${escapeHtml(imgSrc)}" alt="·∫¢nh ƒë√£ t·∫£i l√™n" />`
          : '';

        return `
          <div class="msg-row ${cls}" data-idx="${idx}">
            ${m.role === 'assistant' ? '<div class="avatar assistant">F</div>' : ''}
            <div class="bubble ${cls}">
              ${metaHtml}
              ${contentHtml}
              ${imageHtml}
              ${m.productsHtml || ''}
              ${m.sourcesHtml || ''}
            </div>
          </div>
        `;
      }).join('');
      chatWindow.scrollTop = chatWindow.scrollHeight;
    }

    function inferGenderFilterFromText(text) {
      const t = String(text || '').toLowerCase();
      if (/\b(unisex)\b/.test(t)) return 'Unisex';
      if (/\b(women|womens|woman|female|ladies)\b/.test(t)) return 'Women';
      if (/\b(men|mens|man|male|gents)\b/.test(t)) return 'Men';
      return '';
    }

    function buildSourcesHtml(sources) {
      if (!Array.isArray(sources) || sources.length === 0) return '';
      const items = sources.map((s, idx) => {
        const id = (s.metadata && s.metadata.id) ? s.metadata.id : (s.id || '');
        const price = (s.metadata && s.metadata.price) ? `, price: ${s.metadata.price}` : '';
        const color = (s.metadata && s.metadata.color) ? `, color: ${s.metadata.color}` : '';
        const text = escapeHtml(s.text || '');
        return `<div class="source-item"><strong>Ngu·ªìn ${idx+1}</strong>: ${id}${price}${color}<br>${text}</div>`;
      }).join('');
      return `<details><summary>Xem ngu·ªìn</summary>${items}</details>`;
    }

    function formatUsd(val) {
      if (val === null || val === undefined || val === '') return '';
      const num = Number(val);
      if (!Number.isFinite(num)) return String(val);
      return `$${num.toFixed(2)}`;
    }

    function normalizeImageSrc(url) {
      const s = String(url || '').trim();
      if (!s) return '';
      // Gi·ªØ nguy√™n URL tuy·ªát ƒë·ªëi / data URL / file URL.
      if (/^(https?:|data:image\/|file:)/i.test(s)) return s;
      // ƒê∆∞·ªùng d·∫´n tuy·ªát ƒë·ªëi tr√™n Windows (vd: C:\path\to\img.jpg)
      if (/^[a-zA-Z]:[\\/]/.test(s)) {
        return 'file:///' + s.replace(/\\/g, '/');
      }
      // Demo n·∫±m ·ªü /demo, nh∆∞ng ƒëa s·ªë path l√† t∆∞∆°ng ƒë·ªëi theo repo root.
      // Th√™m ti·ªÅn t·ªë "../" ƒë·ªÉ path nh∆∞ "datasets/..." ho·∫∑c "archive/..." resolve ƒë√∫ng.
      if (!s.startsWith('../') && !s.startsWith('./')) {
        return '../' + s.replace(/^\/+/, '');
      }
      return s;
    }

    function buildProductsHtml(products) {
      if (!Array.isArray(products) || products.length === 0) return '';
      const cards = products.map((p) => {
        const name = escapeHtml(p.name || p.id || '');
        const img = normalizeImageSrc(p.image_url);
        const price = formatUsd(p.price);
        const color = escapeHtml(p.color || '');
        const gender = escapeHtml(p.gender || '');
        const cat = escapeHtml(p.category || '');
        const sub = escapeHtml(p.subcategory || '');
        const snippet = escapeHtml(p.snippet || '');

        const badges = [
          price ? `<span class="badge">${escapeHtml(price)}</span>` : '',
          color ? `<span class="badge">${color}</span>` : '',
          gender ? `<span class="badge">${gender}</span>` : '',
          cat ? `<span class="badge">${cat}${sub ? ` / ${sub}` : ''}</span>` : '',
        ].filter(Boolean).join('');

        const imgHtml = img
          ? `<div class="product-img-wrap"><img class="product-img" src="${escapeHtml(img)}" alt="${name}" loading="lazy" /></div>`
          : `<div class="product-img-wrap"><span class="muted" style="font-size:12px;">Kh√¥ng c√≥ ·∫£nh</span></div>`;

        const actions = img
          ? `<div class="product-actions"><a class="link-btn" href="${escapeHtml(img)}" target="_blank" rel="noreferrer">M·ªü ·∫£nh</a></div>`
          : '';

        return `
          <div class="product-card">
            ${imgHtml}
            <div class="product-body">
              <div class="product-title">${name}</div>
              <div class="product-meta">${badges}</div>
              ${snippet ? `<div class="product-meta" style="margin-top:6px;">${snippet}</div>` : ''}
              ${actions}
            </div>
          </div>
        `;
      }).join('');

      return `<div class="product-grid">${cards}</div>`;
    }

    function cleanSnippet(text, maxLen = 180) {
      const s = String(text || '').replace(/<[^>]+>/g, ' ').replace(/\s+/g, ' ').trim();
      if (s.length > maxLen) return s.slice(0, maxLen - 1).trimEnd() + '‚Ä¶';
      return s;
    }

    function resultsToProducts(results) {
      if (!Array.isArray(results)) return [];
      return results.map((r) => {
        const meta = (r && r.metadata) ? r.metadata : {};
        return {
          id: r.id,
          name: meta.name || meta.title || r.id,
          image_url: meta.image_url,
          price: meta.price,
          color: meta.color,
          gender: meta.gender,
          category: meta.category,
          subcategory: meta.subcategory,
          snippet: cleanSnippet(r.text || ''),
        };
      });
    }

    // V·ªõi distance c·ªßa Chroma: c√†ng th·∫•p c√†ng gi·ªëng. Ng∆∞·ª°ng n√†y l√† heuristic.
    // N·∫øu distance t·ªët nh·∫•t l·ªõn h∆°n ng∆∞·ª°ng, coi nh∆∞ "kh√¥ng c√≥ match g·∫ßn".
    const IMAGE_MATCH_DISTANCE_THRESHOLD = 0.08;

    async function searchByImageAndPostToChat(file, captionText) {
      const caption = (captionText || '').trim();
      const userMsg = caption ? `üì∑ T√¨m b·∫±ng ·∫£nh: ${caption}` : 'üì∑ T√¨m b·∫±ng ·∫£nh';
      // ‚ÄúCh·ª•p‚Äù ·∫£nh v·ª´a upload v√†o bong b√≥ng chat.
      // (D√πng object URL ƒë·ªÉ UI v·∫´n hi·ªÉn th·ªã ƒë∆∞·ª£c ·∫£nh k·ªÉ c·∫£ sau khi xo√° tr·∫°ng th√°i ƒë√≠nh k√®m.)
      const msgUrl = URL.createObjectURL(file);
      chatObjectUrls.push(msgUrl);
      messages.push({ role: 'user', content: userMsg, ts: Date.now(), imageSrc: msgUrl });
      typingMsgIndex = messages.push({ role: 'assistant', content: '', ts: Date.now(), isTyping: true }) - 1;
      renderChat();

      const fd = new FormData();
      // N·∫øu ƒë√¢y l√† blob d√°n t·ª´ clipboard, cung c·∫•p m·ªôt t√™n file.
      fd.append('file', file, file.name || 'pasted-image.png');

      const resp = await fetch(apiUrl('/search/image/upload?top_k=3'), {
        method: 'POST',
        body: fd,
        signal: inFlightController ? inFlightController.signal : undefined,
      });
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(txt || resp.statusText);
      }
      const data = await resp.json();
      const products = resultsToProducts(data.results || []);
      const bestScore = (data && Array.isArray(data.results) && data.results[0]) ? Number(data.results[0].score) : NaN;
      const hasCloseMatch = Number.isFinite(bestScore) ? (bestScore <= IMAGE_MATCH_DISTANCE_THRESHOLD) : true;

      const assistantContent = products.length
        ? (hasCloseMatch
            ? 'T√¥i ƒë√£ t√¨m b·∫±ng ·∫£nh c·ªßa b·∫°n. ƒê√¢y l√† c√°c k·∫øt qu·∫£ g·∫ßn nh·∫•t t√¥i t√¨m ƒë∆∞·ª£c:'
            : 'T√¥i kh√¥ng t√¨m th·∫•y ƒë√∫ng ch√≠nh x√°c s·∫£n ph·∫©m ƒë√≥ trong d·ªØ li·ªáu. Tuy nhi√™n, ƒë√¢y l√† c√°c m√≥n t∆∞∆°ng t·ª± nh·∫•t m√† t√¥i c√≥:')
        : 'T√¥i kh√¥ng t√¨m ƒë∆∞·ª£c k·∫øt qu·∫£ ƒë·ªß g·∫ßn cho ·∫£nh n√†y. H√£y th·ª≠ ·∫£nh r√µ h∆°n (ch·ª•p ch√≠nh di·ªán, √°nh s√°ng t·ªët).';

      const assistantMsg = {
        role: 'assistant',
        content: assistantContent,
        ts: Date.now(),
        productsHtml: buildProductsHtml(products),
      };

      if (typingMsgIndex >= 0 && messages[typingMsgIndex]) {
        messages[typingMsgIndex] = assistantMsg;
      } else {
        messages.push(assistantMsg);
      }
      typingMsgIndex = -1;
      renderChat();
    }

    async function sendMessage() {
      const content = (chatInput.value || '').trim(); 
      const attached = getAttachedImage();
      const inferredGender = inferGenderFilterFromText(content);
      const topk = 3;
      const temp = 0.2;

      if (!content && !attached) return;

      // N·∫øu c√≥ ·∫£nh ƒë√≠nh k√®m, coi ƒë√¢y l√† m·ªôt l∆∞·ª£t t√¨m theo ·∫£nh.
      // (Text ch·ªâ ƒë√≥ng vai tr√≤ caption tu·ª≥ ch·ªçn.)
      if (attached) {
        // T·∫°o cancel token cho request n√†y.
        inFlightController = new AbortController();
        lastDraftBeforeSend = content;
        setInFlight(true, 'image');
        setChatStatus('ƒêang t·∫£i ·∫£nh l√™n v√† t√¨m ki·∫øm...');
        try {
          await searchByImageAndPostToChat(attached, content);
          setChatStatus('OK');
        } catch (err) {
          if (err && err.name === 'AbortError') {
            // Ng∆∞·ªùi d√πng ƒë√£ hu·ª∑.
            const cancelMsg = { role: 'assistant', content: 'ƒê√£ d·ª´ng. B·∫°n c√≥ th·ªÉ s·ª≠a tin nh·∫Øn v√† g·ª≠i l·∫°i.', ts: Date.now() };
            if (typingMsgIndex >= 0 && messages[typingMsgIndex]) {
              messages[typingMsgIndex] = cancelMsg;
            } else {
              messages.push(cancelMsg);
            }
            typingMsgIndex = -1;
            renderChat();
            setChatStatus('ƒê√£ hu·ª∑');
            chatInput.value = lastDraftBeforeSend || '';
            chatInput.focus();
            return;
          }
          const failMsg = { role: 'assistant', content: 'Xin l·ªói ‚Äî t√¨m ki·∫øm b·∫±ng ·∫£nh th·∫•t b·∫°i.\nChi ti·∫øt: ' + (err.message || err), ts: Date.now() };
          if (typingMsgIndex >= 0 && messages[typingMsgIndex]) {
            messages[typingMsgIndex] = failMsg;
          } else {
            messages.push(failMsg);
          }
          typingMsgIndex = -1;
          renderChat();
          setChatStatus('L·ªói');
        } finally {
          setInFlight(false);
          inFlightController = null;
          chatInput.value = '';
          clearAttachedImage();
        }
        return;
      }

      // Ng∆∞·ª£c l·∫°i: chat vƒÉn b·∫£n b√¨nh th∆∞·ªùng.
      // T·∫°o cancel token cho request n√†y.
      inFlightController = new AbortController();
      lastDraftBeforeSend = content;
      messages.push({ role: 'user', content, ts: Date.now() });
      typingMsgIndex = messages.push({ role: 'assistant', content: '', ts: Date.now(), isTyping: true }) - 1;
      renderChat();
      chatInput.value = '';

      setInFlight(true, 'chat');
      setChatStatus('ƒêang g·ªçi /chat ...');

      const payload = {
        query: content,
        messages: messages.filter(m => !m.isTyping).map(m => ({ role: m.role, content: m.content })),
        top_k: topk,
        filters: inferredGender ? { gender: inferredGender } : {},
        max_tokens: 256,
        temperature: temp,
      };

      try {
        const resp = await fetch(apiUrl('/chat'), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
          signal: inFlightController.signal,
        });
        if (!resp.ok) {
          const txt = await resp.text();
          throw new Error(txt || resp.statusText);
        }
        const data = await resp.json();
        const assistantMsg = {
          role: 'assistant',
          content: data.answer || '',
          ts: Date.now(),
          productsHtml: buildProductsHtml(data.products),
          sourcesHtml: buildSourcesHtml(data.sources)
        };
        if (typingMsgIndex >= 0 && messages[typingMsgIndex]) {
          messages[typingMsgIndex] = assistantMsg;
        } else {
          messages.push(assistantMsg);
        }
        typingMsgIndex = -1;
        renderChat();
        setChatStatus('OK');
      } catch (err) {
        if (err && err.name === 'AbortError') {
          const cancelMsg = { role: 'assistant', content: 'ƒê√£ d·ª´ng. B·∫°n c√≥ th·ªÉ s·ª≠a c√¢u h·ªèi v√† g·ª≠i l·∫°i.', ts: Date.now() };
          if (typingMsgIndex >= 0 && messages[typingMsgIndex]) {
            messages[typingMsgIndex] = cancelMsg;
          } else {
            messages.push(cancelMsg);
          }
          typingMsgIndex = -1;
          renderChat();
          setChatStatus('ƒê√£ hu·ª∑');
          chatInput.value = lastDraftBeforeSend || '';
          chatInput.focus();
          return;
        }
        const failMsg = { role: 'assistant', content: 'Xin l·ªói ‚Äî kh√¥ng th·ªÉ k·∫øt n·ªëi t·ªõi server ho·∫∑c server tr·∫£ v·ªÅ l·ªói.\nChi ti·∫øt: ' + (err.message || err), ts: Date.now() };
        if (typingMsgIndex >= 0 && messages[typingMsgIndex]) {
          messages[typingMsgIndex] = failMsg;
        } else {
          messages.push(failMsg);
        }
        typingMsgIndex = -1;
        renderChat();
        setChatStatus('L·ªói');
      } finally {
        setInFlight(false);
        inFlightController = null;
      }
    }

    function clearChat() {
      messages.length = 0;
      typingMsgIndex = -1;

      // Revoke c√°c object URL ƒë√£ t·∫°o cho ·∫£nh trong bong b√≥ng chat.
      while (chatObjectUrls.length) {
        const u = chatObjectUrls.pop();
        try { URL.revokeObjectURL(u); } catch (_) {}
      }

      clearAttachedImage();
      renderChat();
      setChatStatus('ƒê√£ b·∫Øt ƒë·∫ßu chat m·ªõi.');
      chatInput.focus();
    }

    sendBtn.addEventListener('click', sendMessage);
    stopBtn.addEventListener('click', stopGenerating);
    clearBtn.addEventListener('click', clearChat);

    attachBtn.addEventListener('click', () => chatImageFile.click());
    removeImageBtn.addEventListener('click', clearAttachedImage);
    chatImageFile.addEventListener('change', () => {
      const f = (chatImageFile.files && chatImageFile.files[0]) ? chatImageFile.files[0] : null;
      if (!f) {
        // Ch·ªâ xo√° l·ª±a ch·ªçn file; v·∫´n gi·ªØ ·∫£nh d√°n n·∫øu ƒëang c√≥.
        chatImageFile.value = '';
        if (!pastedImageFile) {
          chatImagePreview.src = '';
          chatImagePreviewWrap.style.display = 'none';
        }
        return;
      }
      // N·∫øu ch·ªçn file local, xo√° ·∫£nh d√°n ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n.
      pastedImageFile = null;
      if (pastedObjectUrl) {
        try { URL.revokeObjectURL(pastedObjectUrl); } catch (_) {}
        pastedObjectUrl = null;
      }
      const url = URL.createObjectURL(f);
      chatImagePreview.src = url;
      chatImagePreviewWrap.style.display = 'block';
      setChatStatus('ƒê√£ ƒë√≠nh k√®m ·∫£nh. B·∫•m ‚ÄúG·ª≠i‚Äù ƒë·ªÉ t√¨m ki·∫øm.');
    });

    // X·ª≠ l√Ω d√°n: cho ph√©p Ctrl+V ·∫£nh copy t·ª´ internet.
    // L∆∞u √Ω: m·ªôt s·ªë website ch·ªâ copy URL/HTML; demo n√†y ch·ªâ h·ªó tr·ª£ byte ·∫£nh.
    chatInput.addEventListener('paste', (e) => {
      const cd = e.clipboardData;
      if (!cd) return;

      // 1) Th·ª≠ ƒë·ªçc ·∫£nh th·∫≠t t·ª´ clipboard.
      const items = cd.items ? Array.from(cd.items) : [];
      const imgItem = items.find(it => it && typeof it.type === 'string' && it.type.startsWith('image/'));
      if (imgItem && imgItem.getAsFile) {
        const f = imgItem.getAsFile();
        if (f) {
          // D√πng ·∫£nh d√°n nh∆∞ ·∫£nh ƒë√≠nh k√®m ƒë·ªÉ t√¨m ki·∫øm.
          pastedImageFile = new File([f], 'pasted-image.png', { type: f.type || 'image/png' });
          // Xo√° file input ƒë·ªÉ tr√°nh nh·∫ßm l·∫´n.
          chatImageFile.value = '';
          showPreviewFromBlob(pastedImageFile);
          setChatStatus('ƒê√£ d√°n ·∫£nh t·ª´ clipboard. B·∫•m ‚ÄúG·ª≠i‚Äù ƒë·ªÉ t√¨m ki·∫øm.');
          // Tr√°nh ƒë·ªÉ ·∫£nh b·ªã d√°n v√†o textarea nh∆∞ text.
          e.preventDefault();
          return;
        }
      }
    });
    chatInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    // Kh·ªüi t·∫°o
    const apiBaseLabel = document.getElementById('apiBaseLabel');
    if (apiBaseLabel) apiBaseLabel.textContent = API_BASE;

    messages.push({ role: 'assistant', content: "Ch√†o b·∫°n! H√¥m nay b·∫°n mu·ªën mua g√¨? H√£y cho t√¥i bi·∫øt d·ªãp s·ª≠ d·ª•ng, ng√¢n s√°ch v√† size/fit (n·∫øu c√≥).", ts: Date.now() });
    renderChat();
  </script>
</body>
</html>
